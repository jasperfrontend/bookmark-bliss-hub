// src/pages/Hub.tsx (Refactored - Clean and Modular with Proper React Query)
import React, { useState, useMemo, useEffect } from 'react';
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useBookmarks } from '@/hooks/useBookmarks';
import { useSmartCollections } from '@/hooks/useSmartCollections';
import { useCompactMode } from '@/hooks/useCompactMode';
import { Header } from '@/components/Header';
import { BookmarkDialog } from '@/components/BookmarkDialog';
import { SmartCollectionEditDialog } from '@/components/SmartCollectionEditDialog';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { TooltipProvider } from '@/components/ui/tooltip';
import { Trash2 } from 'lucide-react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { SmartCollectionsColumn, RecentBookmarksColumn, ForgottenBookmarksColumn } from '@/components/HubColumns';
import { HubModals } from '@/components/HubModals';

interface Bookmark {
  id: string;
  title: string;
  url: string;
  description?: string;
  favicon_url?: string;
  tags: string[];
  is_favorite: boolean;
  created_at: string;
  last_visited_at?: string;
}

interface CollectionData {
  collectionId?: string;
  newCollectionTitle?: string;
  removeFromCollection?: boolean;
}

const Hub: React.FC = () => {
  const queryClient = useQueryClient();
  
  // First, get the data using hooks normally
  const { bookmarks, loading, handleDelete, handleBulkDelete, handleToggleFavorite, handleSave, handleUpdateLastVisited } = useBookmarks();
  const { smartCollections, loading: collectionsLoading, deleteSmartCollection, updateSmartCollection, saveAutoGeneratedCollection } = useSmartCollections(bookmarks);
  const { compactMode, setCompactMode } = useCompactMode();

  // Cache the bookmarks data using React Query
  const { data: cachedBookmarks } = useQuery({
    queryKey: ['hub-bookmarks-cache'],
    queryFn: () => bookmarks,
    initialData: bookmarks,
    staleTime: Infinity, // Never consider stale
    gcTime: Infinity, // Never garbage collect
    enabled: bookmarks.length > 0,
  });

  // Cache the smart collections data using React Query  
  const { data: cachedSmartCollections } = useQuery({
    queryKey: ['hub-collections-cache', cachedBookmarks],
    queryFn: () => smartCollections,
    initialData: smartCollections,
    staleTime: Infinity,
    gcTime: Infinity,
    enabled: smartCollections.length > 0,
  });

  // Use cached data when available, otherwise use fresh data
  const finalBookmarks = cachedBookmarks?.length > 0 ? cachedBookmarks : bookmarks;
  const finalSmartCollections = cachedSmartCollections?.length > 0 ? cachedSmartCollections : smartCollections;
  const [selectedBookmarks, setSelectedBookmarks] = useState<string[]>([]);
  const [oldBookmarksDays, setOldBookmarksDays] = useState<string>('100');
  const [recentBookmarksCount, setRecentBookmarksCount] = useState<number>(8);
  const [searchQuery, setSearchQuery] = useState('');
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [editingBookmark, setEditingBookmark] = useState<Bookmark | null>(null);
  const [isCollectionEditDialogOpen, setIsCollectionEditDialogOpen] = useState(false);
  const [editingCollection, setEditingCollection] = useState<{ id: string; title: string } | null>(null);
  const [tagsModalOpen, setTagsModalOpen] = useState(false);
  const [selectedBookmarkForTags, setSelectedBookmarkForTags] = useState<Bookmark | null>(null);
  const [actionsModalOpen, setActionsModalOpen] = useState(false);
  const [selectedBookmarkForActions, setSelectedBookmarkForActions] = useState<Bookmark | null>(null);
  
  const navigate = useNavigate();
  const [searchParams, setSearchParams] = useSearchParams();

  // Get expanded collections from URL parameters
  const expandedCollections = useMemo(() => {
    const expanded = searchParams.get('expanded');
    const expandedSet = expanded ? new Set(expanded.split(',').filter(Boolean)) : new Set<string>();
    
    finalSmartCollections.forEach(collection => {
      if (collection.id.startsWith('auto-')) {
        expandedSet.add(collection.id);
      }
    });
    
    return expandedSet;
  }, [searchParams, finalSmartCollections]);

  // Function to update expanded collections in URL
  const updateExpandedCollections = (collectionId: string, isExpanded: boolean) => {
    const newExpanded = new Set(expandedCollections);
    
    if (isExpanded) {
      newExpanded.add(collectionId);
    } else {
      newExpanded.delete(collectionId);
    }

    const expandedArray = Array.from(newExpanded).filter(id => !id.startsWith('auto-'));
    const newParams = new URLSearchParams(searchParams);
    
    if (expandedArray.length > 0) {
      newParams.set('expanded', expandedArray.join(','));
    } else {
      newParams.delete('expanded');
    }
    
    setSearchParams(newParams, { replace: true });
  };

  // Debounced redirect to search when searchQuery changes
  useEffect(() => {
    if (!searchQuery.trim()) return;

    const delayedSearch = setTimeout(() => {
      navigate(`/search?q=${encodeURIComponent(searchQuery.trim())}`);
    }, 1000);

    return () => clearTimeout(delayedSearch);
  }, [searchQuery, navigate]);

  // Get recent bookmarks (adjustable count)
  const recentBookmarks = useMemo(() => {
    return [...finalBookmarks]
      .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())
      .slice(0, recentBookmarksCount);
  }, [finalBookmarks, recentBookmarksCount]);

  // Get forgotten bookmarks based on last_visited_at
  const forgottenBookmarks = useMemo(() => {
    const days = parseInt(oldBookmarksDays);
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);
    
    return finalBookmarks
      .filter(bookmark => {
        const lastVisitedDate = bookmark.last_visited_at 
          ? new Date(bookmark.last_visited_at) 
          : new Date(bookmark.created_at);
        return lastVisitedDate < cutoffDate;
      })
      .sort((a, b) => {
        const aDate = a.last_visited_at ? new Date(a.last_visited_at) : new Date(a.created_at);
        const bDate = b.last_visited_at ? new Date(b.last_visited_at) : new Date(b.created_at);
        return aDate.getTime() - bDate.getTime();
      });
  }, [finalBookmarks, oldBookmarksDays]);

  // Event handlers with cache updates
  const handleBulkDeleteSelected = async () => {
    await handleBulkDelete(selectedBookmarks);
    setSelectedBookmarks([]);
    // Update cached data
    queryClient.setQueryData(['hub-bookmarks-cache'], (oldData: Bookmark[]) => 
      oldData?.filter(bookmark => !selectedBookmarks.includes(bookmark.id)) || []
    );
  };

  const handleEdit = (bookmark: Bookmark) => {
    setEditingBookmark(bookmark);
    setIsDialogOpen(true);
  };

  const handleBookmarkSave = async (
    bookmarkData: Omit<Bookmark, 'id' | 'created_at'> & { id?: string }, 
    collectionData?: CollectionData
  ) => {
    await handleSave(bookmarkData, collectionData);
    setIsDialogOpen(false);
    setEditingBookmark(null);
    // Invalidate cache to refresh data
    queryClient.invalidateQueries({ queryKey: ['hub-bookmarks-cache'] });
    queryClient.invalidateQueries({ queryKey: ['hub-collections-cache'] });
  };

  const handleDeleteCollection = async (collectionId: string) => {
    const isAutoGenerated = collectionId.startsWith('auto-');
    
    if (isAutoGenerated) {
      const collection = finalSmartCollections.find(c => c.id === collectionId);
      if (collection) {
        const savedId = await saveAutoGeneratedCollection(collection);
        if (savedId) {
          await deleteSmartCollection(savedId);
        }
      }
    } else {
      await deleteSmartCollection(collectionId);
    }
    // Invalidate collections cache
    queryClient.invalidateQueries({ queryKey: ['hub-collections-cache'] });
  };

  const handleCollectionSave = async (collectionId: string, newTitle: string) => {
    await updateSmartCollection(collectionId, newTitle);
    setIsCollectionEditDialogOpen(false);
    setEditingCollection(null);
    queryClient.invalidateQueries({ queryKey: ['hub-collections-cache'] });
  };

  // Modal handlers
  const handleTagsClick = (bookmark: Bookmark) => {
    setSelectedBookmarkForTags(bookmark);
    setTagsModalOpen(true);
  };

  const handleActionsClick = (bookmark: Bookmark) => {
    setSelectedBookmarkForActions(bookmark);
    setActionsModalOpen(true);
  };

  const handleToggleFavoriteWrapper = (id: string, isFavorite: boolean) => {
    handleToggleFavorite(id, !isFavorite);
    // Update cached data optimistically
    queryClient.setQueryData(['hub-bookmarks-cache'], (oldData: Bookmark[]) => 
      oldData?.map(bookmark => 
        bookmark.id === id ? { ...bookmark, is_favorite: !isFavorite } : bookmark
      ) || []
    );
  };

  const handleDeleteWrapper = (id: string) => {
    handleDelete(id);
    // Update cached data
    queryClient.setQueryData(['hub-bookmarks-cache'], (oldData: Bookmark[]) => 
      oldData?.filter(bookmark => bookmark.id !== id) || []
    );
    queryClient.invalidateQueries({ queryKey: ['hub-collections-cache'] });
  };

  const handleUpdateLastVisitedWrapper = (id: string) => {
    handleUpdateLastVisited(id);
    // Update cached data with current timestamp
    queryClient.setQueryData(['hub-bookmarks-cache'], (oldData: Bookmark[]) => 
      oldData?.map(bookmark => 
        bookmark.id === id ? { ...bookmark, last_visited_at: new Date().toISOString() } : bookmark
      ) || []
    );
  };

  // Add keyboard shortcut handler
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.altKey && event.key === 'a') {
        event.preventDefault();
        setIsDialogOpen(true);
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, []);

  if (loading || collectionsLoading) {
    return (
      <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
        <Header 
          onAddBookmark={() => setIsDialogOpen(true)}
          searchQuery={searchQuery}
          onSearchChange={setSearchQuery}
          viewMode="grid"
          compactMode={compactMode}
          onCompactModeChange={setCompactMode}
          bookmarkCount={finalBookmarks.length}
          favoritesCount={finalBookmarks.filter(b => b.is_favorite).length}
        />
        <div className="container mx-auto px-4 py-8">
          <div className="flex items-center justify-center py-12">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <TooltipProvider>
      <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
        <Header 
          onAddBookmark={() => setIsDialogOpen(true)}
          searchQuery={searchQuery}
          onSearchChange={setSearchQuery}
          viewMode="grid"
          compactMode={compactMode}
          onCompactModeChange={setCompactMode}
          bookmarkCount={bookmarks.length}
          favoritesCount={bookmarks.filter(b => b.is_favorite).length}
        />
        
        {/* Page Header */}
        <div className="border-b border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800">
          <div className="w-full px-6 py-4">
            <div className="flex items-center justify-between">
              <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Smart Hub</h1>
              <div className="flex items-center gap-3">
                {selectedBookmarks.length > 0 && (
                  <Button
                    onClick={handleBulkDeleteSelected}
                    variant="destructive"
                    size="sm"
                    className="gap-2"
                  >
                    <Trash2 className="h-4 w-4" />
                    Delete {selectedBookmarks.length} Selected
                  </Button>
                )}
                <Badge variant="secondary" className="text-sm">
                  {finalBookmarks.length} total bookmarks
                </Badge>
              </div>
            </div>
          </div>
        </div>

        {/* Trello-style 3-column Layout */}
        <div className="w-full h-[calc(100vh-140px)] flex gap-4 p-4 overflow-hidden">
          
          <SmartCollectionsColumn
            smartCollections={finalSmartCollections}
            expandedCollections={expandedCollections}
            selectedBookmarks={selectedBookmarks}
            onToggleExpanded={updateExpandedCollections}
            onDeleteCollection={handleDeleteCollection}
            onSelectionChange={setSelectedBookmarks}
            onEdit={handleEdit}
            onDelete={handleDeleteWrapper}
            onToggleFavorite={handleToggleFavoriteWrapper}
            onUpdateLastVisited={handleUpdateLastVisitedWrapper}
            onTagsClick={handleTagsClick}
            onActionsClick={handleActionsClick}
          />

          <RecentBookmarksColumn
            recentBookmarks={recentBookmarks}
            recentBookmarksCount={recentBookmarksCount}
            selectedBookmarks={selectedBookmarks}
            setRecentBookmarksCount={setRecentBookmarksCount}
            onSelectionChange={setSelectedBookmarks}
            onEdit={handleEdit}
            onDelete={handleDeleteWrapper}
            onToggleFavorite={handleToggleFavoriteWrapper}
            onUpdateLastVisited={handleUpdateLastVisitedWrapper}
            onTagsClick={handleTagsClick}
            onActionsClick={handleActionsClick}
          />

          <ForgottenBookmarksColumn
            forgottenBookmarks={forgottenBookmarks}
            oldBookmarksDays={oldBookmarksDays}
            selectedBookmarks={selectedBookmarks}
            setOldBookmarksDays={setOldBookmarksDays}
            onSelectionChange={setSelectedBookmarks}
            onEdit={handleEdit}
            onDelete={handleDeleteWrapper}
            onToggleFavorite={handleToggleFavoriteWrapper}
            onUpdateLastVisited={handleUpdateLastVisitedWrapper}
            onTagsClick={handleTagsClick}
            onActionsClick={handleActionsClick}
          />
        </div>

        {/* Main Dialogs */}
        <BookmarkDialog
          open={isDialogOpen}
          onOpenChange={(open) => {
            setIsDialogOpen(open);
            if (!open) {
              setEditingBookmark(null);
            }
          }}
          bookmark={editingBookmark}
          existingBookmarks={finalBookmarks}
          onSave={handleBookmarkSave}
        />

        <SmartCollectionEditDialog
          open={isCollectionEditDialogOpen}
          onOpenChange={(open) => {
            setIsCollectionEditDialogOpen(open);
            if (!open) {
              setEditingCollection(null);
            }
          }}
          collection={editingCollection}
          onSave={handleCollectionSave}
        />

        {/* Hub-specific Modals */}
        <HubModals
          tagsModalOpen={tagsModalOpen}
          setTagsModalOpen={setTagsModalOpen}
          selectedBookmarkForTags={selectedBookmarkForTags}
          actionsModalOpen={actionsModalOpen}
          setActionsModalOpen={setActionsModalOpen}
          selectedBookmarkForActions={selectedBookmarkForActions}
          onEdit={handleEdit}
          onDelete={handleDeleteWrapper}
          onToggleFavorite={handleToggleFavoriteWrapper}
          onUpdateLastVisited={handleUpdateLastVisitedWrapper}
        />
      </div>
    </TooltipProvider>
  );
};

export default Hub;