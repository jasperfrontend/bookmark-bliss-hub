// src/pages/Hub.tsx (Fixed - Stabilize bookmarks reference)
import React, { useState, useMemo, useEffect, useRef } from 'react';
import { useBookmarks } from '@/hooks/useBookmarks';
import { useSmartCollections } from '@/hooks/useSmartCollections';
import { useCompactMode } from '@/hooks/useCompactMode';
import { Header } from '@/components/Header';
import { BookmarkDialog } from '@/components/BookmarkDialog';
import { SmartCollectionEditDialog } from '@/components/SmartCollectionEditDialog';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { TooltipProvider } from '@/components/ui/tooltip';
import { Trash2 } from 'lucide-react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { SmartCollectionsColumn, RecentBookmarksColumn, ForgottenBookmarksColumn } from '@/components/HubColumns';
import { HubModals } from '@/components/HubModals';

interface Bookmark {
  id: string;
  title: string;
  url: string;
  description?: string;
  favicon_url?: string;
  tags: string[];
  is_favorite: boolean;
  created_at: string;
  last_visited_at?: string;
}

interface CollectionData {
  collectionId?: string;
  newCollectionTitle?: string;
  removeFromCollection?: boolean;
}

const Hub: React.FC = () => {
  // Use hooks directly without additional caching layers
  const { bookmarks, loading, handleDelete, handleBulkDelete, handleToggleFavorite, handleSave, handleUpdateLastVisited } = useBookmarks();
  const { compactMode, setCompactMode } = useCompactMode();

  // Stabilize bookmarks reference to prevent unnecessary smart collections recalculation
  const stableBookmarks = useMemo(() => {
    // Create a stable reference based on bookmark IDs and their key properties
    const bookmarkSignature = bookmarks.map(b => `${b.id}-${b.created_at}-${b.tags.join(',')}`).join('|');
    return bookmarks;
  }, [
    // Only update when the actual content changes, not just array reference
    bookmarks.length,
    bookmarks.map(b => b.id).join(','),
    bookmarks.map(b => b.created_at).join(','),
    bookmarks.map(b => b.tags.join(',')).join('|')
  ]);

  const { smartCollections, loading: collectionsLoading, deleteSmartCollection, updateSmartCollection, saveAutoGeneratedCollection } = useSmartCollections(stableBookmarks);

  const [selectedBookmarks, setSelectedBookmarks] = useState<string[]>([]);
  const [oldBookmarksDays, setOldBookmarksDays] = useState<string>('100');
  const [recentBookmarksCount, setRecentBookmarksCount] = useState<number>(8);
  const [searchQuery, setSearchQuery] = useState('');
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [editingBookmark, setEditingBookmark] = useState<Bookmark | null>(null);
  const [isCollectionEditDialogOpen, setIsCollectionEditDialogOpen] = useState(false);
  const [editingCollection, setEditingCollection] = useState<{ id: string; title: string } | null>(null);
  const [tagsModalOpen, setTagsModalOpen] = useState(false);
  const [selectedBookmarkForTags, setSelectedBookmarkForTags] = useState<Bookmark | null>(null);
  const [actionsModalOpen, setActionsModalOpen] = useState(false);
  const [selectedBookmarkForActions, setSelectedBookmarkForActions] = useState<Bookmark | null>(null);
  
  const navigate = useNavigate();
  const [searchParams, setSearchParams] = useSearchParams();

  // Get expanded collections from URL parameters
  const expandedCollections = useMemo(() => {
    const expanded = searchParams.get('expanded');
    const expandedSet = expanded ? new Set(expanded.split(',').filter(Boolean)) : new Set<string>();
    
    smartCollections.forEach(collection => {
      if (collection.id.startsWith('auto-')) {
        expandedSet.add(collection.id);
      }
    });
    
    return expandedSet;
  }, [searchParams, smartCollections]);

  // Function to update expanded collections in URL
  const updateExpandedCollections = (collectionId: string, isExpanded: boolean) => {
    const newExpanded = new Set(expandedCollections);
    
    if (isExpanded) {
      newExpanded.add(collectionId);
    } else {
      newExpanded.delete(collectionId);
    }

    const expandedArray = Array.from(newExpanded).filter(id => !id.startsWith('auto-'));
    const newParams = new URLSearchParams(searchParams);
    
    if (expandedArray.length > 0) {
      newParams.set('expanded', expandedArray.join(','));
    } else {
      newParams.delete('expanded');
    }
    
    setSearchParams(newParams, { replace: true });
  };

  // Debounced redirect to search when searchQuery changes
  useEffect(() => {
    if (!searchQuery.trim()) return;

    const delayedSearch = setTimeout(() => {
      navigate(`/search?q=${encodeURIComponent(searchQuery.trim())}`);
    }, 1000);

    return () => clearTimeout(delayedSearch);
  }, [searchQuery, navigate]);

  // Memoized computed values to prevent unnecessary recalculations
  const recentBookmarks = useMemo(() => {
    return [...bookmarks]
      .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())
      .slice(0, recentBookmarksCount);
  }, [bookmarks, recentBookmarksCount]);

  const forgottenBookmarks = useMemo(() => {
    const days = parseInt(oldBookmarksDays);
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);
    
    return bookmarks
      .filter(bookmark => {
        const lastVisitedDate = bookmark.last_visited_at 
          ? new Date(bookmark.last_visited_at) 
          : new Date(bookmark.created_at);
        return lastVisitedDate < cutoffDate;
      })
      .sort((a, b) => {
        const aDate = a.last_visited_at ? new Date(a.last_visited_at) : new Date(a.created_at);
        const bDate = b.last_visited_at ? new Date(b.last_visited_at) : new Date(b.created_at);
        return aDate.getTime() - bDate.getTime();
      });
  }, [bookmarks, oldBookmarksDays]);

  const favoritesCount = useMemo(() => {
    return bookmarks.filter(b => b.is_favorite).length;
  }, [bookmarks]);

  // Event handlers
  const handleBulkDeleteSelected = async () => {
    await handleBulkDelete(selectedBookmarks);
    setSelectedBookmarks([]);
  };

  const handleEdit = (bookmark: Bookmark) => {
    setEditingBookmark(bookmark);
    setIsDialogOpen(true);
  };

  const handleBookmarkSave = async (
    bookmarkData: Omit<Bookmark, 'id' | 'created_at'> & { id?: string }, 
    collectionData?: CollectionData
  ) => {
    await handleSave(bookmarkData, collectionData);
    setIsDialogOpen(false);
    setEditingBookmark(null);
  };

  const handleDeleteCollection = async (collectionId: string) => {
    const isAutoGenerated = collectionId.startsWith('auto-');
    
    if (isAutoGenerated) {
      const collection = smartCollections.find(c => c.id === collectionId);
      if (collection) {
        const savedId = await saveAutoGeneratedCollection(collection);
        if (savedId) {
          await deleteSmartCollection(savedId);
        }
      }
    } else {
      await deleteSmartCollection(collectionId);
    }
  };

  const handleCollectionSave = async (collectionId: string, newTitle: string) => {
    await updateSmartCollection(collectionId, newTitle);
    setIsCollectionEditDialogOpen(false);
    setEditingCollection(null);
  };

  // Modal handlers
  const handleTagsClick = (bookmark: Bookmark) => {
    setSelectedBookmarkForTags(bookmark);
    setTagsModalOpen(true);
  };

  const handleActionsClick = (bookmark: Bookmark) => {
    setSelectedBookmarkForActions(bookmark);
    setActionsModalOpen(true);
  };

  // Add keyboard shortcut handler
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.altKey && event.key === 'a') {
        event.preventDefault();
        setIsDialogOpen(true);
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, []);

  if (loading || collectionsLoading) {
    return (
      <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
        <Header 
          onAddBookmark={() => setIsDialogOpen(true)}
          searchQuery={searchQuery}
          onSearchChange={setSearchQuery}
          viewMode="grid"
          compactMode={compactMode}
          onCompactModeChange={setCompactMode}
          bookmarkCount={bookmarks.length}
          favoritesCount={favoritesCount}
        />
        <div className="container mx-auto px-4 py-8">
          <div className="flex items-center justify-center py-12">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <TooltipProvider>
      <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
        <Header 
          onAddBookmark={() => setIsDialogOpen(true)}
          searchQuery={searchQuery}
          onSearchChange={setSearchQuery}
          viewMode="grid"
          compactMode={compactMode}
          onCompactModeChange={setCompactMode}
          bookmarkCount={bookmarks.length}
          favoritesCount={favoritesCount}
        />
        
        {/* Page Header */}
        <div className="border-b border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800">
          <div className="w-full px-6 py-4">
            <div className="flex items-center justify-between">
              <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Smart Hub</h1>
              <div className="flex items-center gap-3">
                {selectedBookmarks.length > 0 && (
                  <Button
                    onClick={handleBulkDeleteSelected}
                    variant="destructive"
                    size="sm"
                    className="gap-2"
                  >
                    <Trash2 className="h-4 w-4" />
                    Delete {selectedBookmarks.length} Selected
                  </Button>
                )}
                <Badge variant="secondary" className="text-sm">
                  {bookmarks.length} total bookmarks
                </Badge>
              </div>
            </div>
          </div>
        </div>

        {/* Trello-style 3-column Layout */}
        <div className="w-full h-[calc(100vh-140px)] flex gap-4 p-4 overflow-hidden">
          
          <SmartCollectionsColumn
            smartCollections={smartCollections}
            expandedCollections={expandedCollections}
            selectedBookmarks={selectedBookmarks}
            onToggleExpanded={updateExpandedCollections}
            onDeleteCollection={handleDeleteCollection}
            onSelectionChange={setSelectedBookmarks}
            onEdit={handleEdit}
            onDelete={handleDelete}
            onToggleFavorite={handleToggleFavorite}
            onUpdateLastVisited={handleUpdateLastVisited}
            onTagsClick={handleTagsClick}
            onActionsClick={handleActionsClick}
          />

          <RecentBookmarksColumn
            recentBookmarks={recentBookmarks}
            recentBookmarksCount={recentBookmarksCount}
            selectedBookmarks={selectedBookmarks}
            setRecentBookmarksCount={setRecentBookmarksCount}
            onSelectionChange={setSelectedBookmarks}
            onEdit={handleEdit}
            onDelete={handleDelete}
            onToggleFavorite={handleToggleFavorite}
            onUpdateLastVisited={handleUpdateLastVisited}
            onTagsClick={handleTagsClick}
            onActionsClick={handleActionsClick}
          />

          <ForgottenBookmarksColumn
            forgottenBookmarks={forgottenBookmarks}
            oldBookmarksDays={oldBookmarksDays}
            selectedBookmarks={selectedBookmarks}
            setOldBookmarksDays={setOldBookmarksDays}
            onSelectionChange={setSelectedBookmarks}
            onEdit={handleEdit}
            onDelete={handleDelete}
            onToggleFavorite={handleToggleFavorite}
            onUpdateLastVisited={handleUpdateLastVisited}
            onTagsClick={handleTagsClick}
            onActionsClick={handleActionsClick}
          />
        </div>

        {/* Main Dialogs */}
        <BookmarkDialog
          open={isDialogOpen}
          onOpenChange={(open) => {
            setIsDialogOpen(open);
            if (!open) {
              setEditingBookmark(null);
            }
          }}
          bookmark={editingBookmark}
          existingBookmarks={bookmarks}
          onSave={handleBookmarkSave}
        />

        <SmartCollectionEditDialog
          open={isCollectionEditDialogOpen}
          onOpenChange={(open) => {
            setIsCollectionEditDialogOpen(open);
            if (!open) {
              setEditingCollection(null);
            }
          }}
          collection={editingCollection}
          onSave={handleCollectionSave}
        />

        {/* Hub-specific Modals */}
        <HubModals
          tagsModalOpen={tagsModalOpen}
          setTagsModalOpen={setTagsModalOpen}
          selectedBookmarkForTags={selectedBookmarkForTags}
          actionsModalOpen={actionsModalOpen}
          setActionsModalOpen={setActionsModalOpen}
          selectedBookmarkForActions={selectedBookmarkForActions}
          onEdit={handleEdit}
          onDelete={handleDelete}
          onToggleFavorite={handleToggleFavorite}
          onUpdateLastVisited={handleUpdateLastVisited}
        />
      </div>
    </TooltipProvider>
  );
};

export default Hub;