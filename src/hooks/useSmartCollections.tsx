import { useState, useEffect, useMemo } from 'react';
import { useAuth } from '@/contexts/AuthContext';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { TemporalClustering } from '@/utils/temporalClustering';
import type { SmartCollection, Bookmark } from '@/types/smartCollections';

// Extended type for collections with bookmarks
export interface ExtendedSmartCollection extends SmartCollection {
  bookmarks?: Bookmark[];
  timeRange?: {
    start: string;
    end: string;
  };
}

export const useSmartCollections = (bookmarks: Bookmark[]) => {
  const [dbCollections, setDbCollections] = useState<ExtendedSmartCollection[]>([]);
  const [loading, setLoading] = useState(true);
  const [deletedAutoCollectionIds, setDeletedAutoCollectionIds] = useState<Set<string>>(new Set());
  const { user } = useAuth();
  const { toast } = useToast();

  const fetchSmartCollections = async () => {
    if (!user) return;

    setLoading(true);
    try {
      // Fetch collections from database
      const { data: collections, error: collectionsError } = await supabase
        .from('smart_collections')
        .select(`
          *,
          collection_bookmarks (
            bookmark_id,
            bookmarks (
              id,
              title,
              url,
              description,
              favicon_url,
              tags,
              is_favorite,
              created_at
            )
          )
        `)
        .eq('user_id', user.id)
        .order('created_at', { ascending: false });

      if (collectionsError) throw collectionsError;

      // Transform the data to match our ExtendedSmartCollection type
      const transformedCollections: ExtendedSmartCollection[] = collections?.map(collection => ({
        ...collection,
        bookmarks: collection.collection_bookmarks?.map(cb => cb.bookmarks).filter(Boolean) || []
      })) || [];

      setDbCollections(transformedCollections);
    } catch (error) {
      console.error('Error fetching smart collections:', error);
      toast({
        title: "Error",
        description: "Failed to fetch smart collections",
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  };

  const saveAutoGeneratedCollection = async (collection: ExtendedSmartCollection) => {
    if (!user) return null;

    try {
      // First, save the collection to the database
      const { data: savedCollection, error: collectionError } = await supabase
        .from('smart_collections')
        .insert({
          title: collection.title,
          type: collection.type,
          confidence: collection.confidence,
          keywords: collection.keywords,
          time_range_start: collection.timeRange?.start || collection.time_range_start,
          time_range_end: collection.timeRange?.end || collection.time_range_end,
          user_id: user.id
        })
        .select()
        .single();

      if (collectionError) throw collectionError;

      // Then, save the bookmark relationships
      if (collection.bookmarks && collection.bookmarks.length > 0) {
        const bookmarkRelations = collection.bookmarks.map(bookmark => ({
          collection_id: savedCollection.id,
          bookmark_id: bookmark.id
        }));

        const { error: relationsError } = await supabase
          .from('collection_bookmarks')
          .insert(bookmarkRelations);

        if (relationsError) throw relationsError;
      }

      // Refresh the collections list
      await fetchSmartCollections();

      toast({
        title: "Success",
        description: "Smart collection saved successfully",
      });

      return savedCollection.id;
    } catch (error) {
      console.error('Error saving auto-generated collection:', error);
      toast({
        title: "Error",
        description: "Failed to save smart collection",
        variant: "destructive"
      });
      return null;
    }
  };

  const deleteSmartCollection = async (collectionId: string) => {
    if (!user) return;

    try {
      // Check if this is an auto-generated collection
      const isAutoGenerated = collectionId.startsWith('auto-');
      
      if (isAutoGenerated) {
        // Generate fresh collections to find the one being deleted
        const availableBookmarks = bookmarks.filter(bookmark => 
          !usedBookmarkIds.has(bookmark.id) && 
          !(bookmark.tags && bookmark.tags.includes('dismissed'))
        );
        
        if (availableBookmarks.length >= 3) {
          const freshCollections = TemporalClustering.generateSmartCollections(availableBookmarks);
          
          // Find the collection by recreating its stable ID
          const targetCollection = freshCollections.find(collection => {
            const titleSlug = collection.title.replace(/\s+/g, '-').toLowerCase();
            const bookmarkIds = collection.bookmarks?.map(b => b.id).sort().join('-');
            const stableId = `auto-${titleSlug}-${bookmarkIds.slice(0, 10)}`;
            return stableId === collectionId;
          });

          if (targetCollection && targetCollection.bookmarks) {
            // Add "dismissed" tag to all bookmarks in this collection
            const bookmarkUpdates = targetCollection.bookmarks.map(async (bookmark) => {
              const existingTags = bookmark.tags || [];
              const updatedTags = existingTags.includes('dismissed') 
                ? existingTags 
                : [...existingTags, 'dismissed'];

              const { error } = await supabase
                .from('bookmarks')
                .update({ 
                  tags: updatedTags,
                  updated_at: new Date().toISOString()
                })
                .eq('id', bookmark.id)
                .eq('user_id', user.id);

              if (error) throw error;
            });

            // Wait for all bookmark updates to complete
            await Promise.all(bookmarkUpdates);
          }
        }

        // Mark the collection as deleted locally
        setDeletedAutoCollectionIds(prev => new Set([...prev, collectionId]));
        
        toast({
          title: "Success",
          description: "Smart collection dismissed and bookmarks tagged to prevent regeneration",
        });
        return;
      }

      // For saved collections, delete from database
      // First delete the collection_bookmarks relationships
      const { error: bookmarksError } = await supabase
        .from('collection_bookmarks')
        .delete()
        .eq('collection_id', collectionId);

      if (bookmarksError) throw bookmarksError;

      // Then delete the collection itself
      const { error: collectionError } = await supabase
        .from('smart_collections')
        .delete()
        .eq('id', collectionId)
        .eq('user_id', user.id);

      if (collectionError) throw collectionError;

      // Update local state
      setDbCollections(prev => prev.filter(collection => collection.id !== collectionId));

      toast({
        title: "Success",
        description: "Smart collection deleted successfully",
      });
    } catch (error) {
      console.error('Error deleting smart collection:', error);
      toast({
        title: "Error",
        description: "Failed to delete smart collection",
        variant: "destructive"
      });
    }
  };

  const updateSmartCollection = async (collectionId: string, newTitle: string) => {
    if (!user) return;

    try {
      const { error } = await supabase
        .from('smart_collections')
        .update({ 
          title: newTitle,
          updated_at: new Date().toISOString()
        })
        .eq('id', collectionId)
        .eq('user_id', user.id);

      if (error) throw error;

      // Update local state
      setDbCollections(prev => prev.map(collection => 
        collection.id === collectionId 
          ? { ...collection, title: newTitle, updated_at: new Date().toISOString() }
          : collection
      ));

      toast({
        title: "Success",
        description: "Smart collection updated successfully",
      });
    } catch (error) {
      console.error('Error updating smart collection:', error);
      toast({
        title: "Error",
        description: "Failed to update smart collection",
        variant: "destructive"
      });
    }
  };

  // Get all bookmark IDs that are already in saved collections
  const usedBookmarkIds = useMemo(() => {
    const ids = new Set<string>();
    dbCollections.forEach(collection => {
      collection.bookmarks?.forEach(bookmark => {
        ids.add(bookmark.id);
      });
    });
    return ids;
  }, [dbCollections]);

  // Generate automatic collections from temporal clustering with stable IDs and excluded bookmarks
  const autoCollections: ExtendedSmartCollection[] = useMemo(() => {
    if (bookmarks.length < 3) return [];
    
    // Filter out bookmarks that are already in saved collections OR have the "dismissed" tag
    const availableBookmarks = bookmarks.filter(bookmark => 
      !usedBookmarkIds.has(bookmark.id) && 
      !(bookmark.tags && bookmark.tags.includes('dismissed'))
    );
    
    if (availableBookmarks.length < 3) return [];

    const generatedCollections = TemporalClustering.generateSmartCollections(availableBookmarks);
    
    return generatedCollections
      .map(collection => {
        // Create a stable ID based on collection content
        const titleSlug = collection.title.replace(/\s+/g, '-').toLowerCase();
        const bookmarkIds = collection.bookmarks?.map(b => b.id).sort().join('-');
        const stableId = `auto-${titleSlug}-${bookmarkIds.slice(0, 10)}`;
        
        return {
          ...collection,
          id: stableId,
          time_range_start: collection.timeRange?.start || null,
          time_range_end: collection.timeRange?.end || null,
          user_id: user?.id || '',
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
          bookmarks: collection.bookmarks || []
        };
      })
      .filter(collection => !deletedAutoCollectionIds.has(collection.id)); // Filter out deleted auto collections
  }, [bookmarks, usedBookmarkIds, deletedAutoCollectionIds, user?.id]);

  // Combine both types of collections
  const allCollections = [...dbCollections, ...autoCollections];

  useEffect(() => {
    fetchSmartCollections();
  }, [user]);

  return {
    smartCollections: allCollections,
    loading,
    refetch: fetchSmartCollections,
    deleteSmartCollection,
    updateSmartCollection,
    saveAutoGeneratedCollection
  };
};
