
import { useState, useEffect } from 'react';
import { useAuth } from '@/contexts/AuthContext';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { TemporalClustering } from '@/utils/temporalClustering';
import type { SmartCollection, Bookmark } from '@/types/smartCollections';

// Extended type for collections with bookmarks
export interface ExtendedSmartCollection extends SmartCollection {
  bookmarks?: Bookmark[];
  timeRange?: {
    start: string;
    end: string;
  };
}

export const useSmartCollections = (bookmarks: Bookmark[]) => {
  const [dbCollections, setDbCollections] = useState<ExtendedSmartCollection[]>([]);
  const [loading, setLoading] = useState(true);
  const { user } = useAuth();
  const { toast } = useToast();

  const fetchSmartCollections = async () => {
    if (!user) return;

    setLoading(true);
    try {
      // Fetch collections from database
      const { data: collections, error: collectionsError } = await supabase
        .from('smart_collections')
        .select(`
          *,
          collection_bookmarks (
            bookmark_id,
            bookmarks (
              id,
              title,
              url,
              description,
              favicon_url,
              tags,
              is_favorite,
              created_at
            )
          )
        `)
        .eq('user_id', user.id)
        .order('created_at', { ascending: false });

      if (collectionsError) throw collectionsError;

      // Transform the data to match our ExtendedSmartCollection type
      const transformedCollections: ExtendedSmartCollection[] = collections?.map(collection => ({
        ...collection,
        bookmarks: collection.collection_bookmarks?.map(cb => cb.bookmarks).filter(Boolean) || []
      })) || [];

      setDbCollections(transformedCollections);
    } catch (error) {
      console.error('Error fetching smart collections:', error);
      toast({
        title: "Error",
        description: "Failed to fetch smart collections",
        variant: "destructive"
      });
    } finally {
      setLoading(false);
    }
  };

  const saveAutoGeneratedCollection = async (collection: ExtendedSmartCollection) => {
    if (!user) return null;

    try {
      // First, save the collection to the database
      const { data: savedCollection, error: collectionError } = await supabase
        .from('smart_collections')
        .insert({
          title: collection.title,
          type: collection.type,
          confidence: collection.confidence,
          keywords: collection.keywords,
          time_range_start: collection.timeRange?.start || collection.time_range_start,
          time_range_end: collection.timeRange?.end || collection.time_range_end,
          user_id: user.id
        })
        .select()
        .single();

      if (collectionError) throw collectionError;

      // Then, save the bookmark relationships
      if (collection.bookmarks && collection.bookmarks.length > 0) {
        const bookmarkRelations = collection.bookmarks.map(bookmark => ({
          collection_id: savedCollection.id,
          bookmark_id: bookmark.id
        }));

        const { error: relationsError } = await supabase
          .from('collection_bookmarks')
          .insert(bookmarkRelations);

        if (relationsError) throw relationsError;
      }

      // Refresh the collections list
      await fetchSmartCollections();

      toast({
        title: "Success",
        description: "Smart collection saved successfully",
      });

      return savedCollection.id;
    } catch (error) {
      console.error('Error saving auto-generated collection:', error);
      toast({
        title: "Error",
        description: "Failed to save smart collection",
        variant: "destructive"
      });
      return null;
    }
  };

  const deleteSmartCollection = async (collectionId: string) => {
    if (!user) return;

    try {
      // First delete the collection_bookmarks relationships
      const { error: bookmarksError } = await supabase
        .from('collection_bookmarks')
        .delete()
        .eq('collection_id', collectionId);

      if (bookmarksError) throw bookmarksError;

      // Then delete the collection itself
      const { error: collectionError } = await supabase
        .from('smart_collections')
        .delete()
        .eq('id', collectionId)
        .eq('user_id', user.id);

      if (collectionError) throw collectionError;

      // Update local state
      setDbCollections(prev => prev.filter(collection => collection.id !== collectionId));

      toast({
        title: "Success",
        description: "Smart collection deleted successfully",
      });
    } catch (error) {
      console.error('Error deleting smart collection:', error);
      toast({
        title: "Error",
        description: "Failed to delete smart collection",
        variant: "destructive"
      });
    }
  };

  const updateSmartCollection = async (collectionId: string, newTitle: string) => {
    if (!user) return;

    try {
      const { error } = await supabase
        .from('smart_collections')
        .update({ 
          title: newTitle,
          updated_at: new Date().toISOString()
        })
        .eq('id', collectionId)
        .eq('user_id', user.id);

      if (error) throw error;

      // Update local state
      setDbCollections(prev => prev.map(collection => 
        collection.id === collectionId 
          ? { ...collection, title: newTitle, updated_at: new Date().toISOString() }
          : collection
      ));

      toast({
        title: "Success",
        description: "Smart collection updated successfully",
      });
    } catch (error) {
      console.error('Error updating smart collection:', error);
      toast({
        title: "Error",
        description: "Failed to update smart collection",
        variant: "destructive"
      });
    }
  };

  // Generate automatic collections from temporal clustering and transform them
  const autoCollections: ExtendedSmartCollection[] = bookmarks.length >= 3 
    ? TemporalClustering.generateSmartCollections(bookmarks).map(collection => ({
        ...collection,
        // Generate a temporary ID for auto-generated collections
        id: `auto-${collection.title.replace(/\s+/g, '-').toLowerCase()}-${Date.now()}`,
        // Ensure all required SmartCollection properties exist
        time_range_start: collection.timeRange?.start || null,
        time_range_end: collection.timeRange?.end || null,
        user_id: user?.id || '',
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        bookmarks: collection.bookmarks || []
      }))
    : [];

  // Combine both types of collections
  const allCollections = [...dbCollections, ...autoCollections];

  useEffect(() => {
    fetchSmartCollections();
  }, [user]);

  return {
    smartCollections: allCollections,
    loading,
    refetch: fetchSmartCollections,
    deleteSmartCollection,
    updateSmartCollection,
    saveAutoGeneratedCollection
  };
};
